<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <title>Project 1</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>

  <style>

  .outlineCount{
      stroke: white;
      stroke-width: .5px;
      fill:none;
    }
    .mouseover {
      stroke-width: 3px;
      pointer-events: none;
    }
    div.projtitle {
      width: 100%;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: darkgrey;

    }

    text.projtitle {
      font-family:sans-serif;
      color: white;
    }

    .active {
        fill: #46b6b6;
    }

    svg {
      display: block;
    }

    .gridlines line {
      stroke: #bbb;
    }

    g.mouseover rect {
      fill: white;
      stroke: #222;
      stroke-width: 1px;
    }
    g.mouseover text {
      font-family: Arial, sans-serif;
    }
    g.mouseover text:first-child {
      font-weight: bold;
    }





  </style>


</head>
<body>
  <div class = "projtitle"> <text class = "projtitle"> Visualizing Maternal Mortality </text> </div>

  <div id="button-bar"></div>
  <svg id="choropleth" height="620" width="1150" style="margin:20px" />
  <svg id="colorLegend" height="100" width="600" style="background: #fff; margin-top:30px" ></svg>
  <svg id="graph" height="500" width="800" >
  </svg>

  <script>



  const requestData = async () => {

    const unicefData = await d3.csv("unicef_final.csv");
    const countryData = await d3.json("countries-110m.json");
    const incomeData = await d3.csv("incomegroups_final.csv");
    var incomeKey





    var unicefCountries = []
    for (i = 0; i < unicefData.length; i++) {
      let country = unicefData[i]["GeographicArea"]
      var n = country.indexOf(":")
      country = country.slice(n+2)
      unicefData[i]["GeographicArea"] = country

      if(unicefCountries.includes(country) === false){
        unicefCountries.push(country)

      }
        }


    var low = {}
    var lowmid = {}
    var upmid = {}
    var high = {}

    // Add income level to unicef countries data
    for (i = 0; i < unicefData.length; i++) {
          let country = unicefData[i]["GeographicArea"]
          row = incomeData.filter( (d) => {return d['Economy'] == country;}  )
          row = row[0]
          if (row != undefined){
            income = row['Income group']
            region = row['Region']
            unicefData[i]["IncomeGroup"] = income
            unicefData[i]["Region"] = region
            }
      }





//ADD data to topojson file:
    data = unicefData.filter( (d) => {return d['TimePeriod'] === "2017";}  );

    var mortvals = {}
    for (i = 0; i < countryData.objects.countries.geometries.length; i++) {
      country = countryData.objects.countries.geometries[i].properties.name
      if (unicefCountries.includes(country)){

        filtered_data = data.filter( (d) => {return d['GeographicArea'] == country;}  )
        var TimePeriod = filtered_data["TimePeriod"]
        var maternal_mortality_ratio = filtered_data[0]["maternal_mortality_ratio"]
        countryData.objects.countries.geometries[i].properties.maternal_mortality_ratio = maternal_mortality_ratio

        mortvals[country] = maternal_mortality_ratio

      }


    }


    var low = {}
    var lowmid = {}
    var upmid = {}
    var high = {}
    var lowCountry = []
    var lowmidCountry = []
    var upmidCountry = []
    var highCountry = []
    var allCountry = []
    for (i = 0; i < data.length; i++) {
      country = data[i]["GeographicArea"]
      ratio = data[i]["maternal_mortality_ratio"]
      income = data[i]["IncomeGroup"]

      if(income =="Low income"){
        low[country] = ratio
        lowCountry.push(country)
        allCountry.push(country)}
        if(income =="Lower middle income"){
          lowmid[country] = ratio
          lowmidCountry.push(country)
          allCountry.push(country)}
        if(income =="Upper middle income"){
          upmid[country] = ratio
          upmidCountry.push(country)
          allCountry.push(country)}
        if(income =="High income"){
          high[country] = ratio
          highCountry.push(country)
          allCountry.push(country)}
  }







    var mortvalsorig = mortvals

//Build bar chart:

    const svg = d3.select("#graph");
    const width = svg.attr("width");
    const height = svg.attr("height");

    const margin = {top: 20, right: 10, bottom: 50, left: 50};
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;

    let annotations = svg.append("g").attr("id","annotations");
    let chartArea = svg.append("g").attr("id","points")
                        .attr("transform",`translate(${margin.left},${margin.top})`);



    // Only show top 10 bars:
    function getTop10(data){
      let top_ratios = []
      let top_countries = []
      for(i = 0; i < 10; i ++){
        let maxiRatio = 0;
        let topiCountry = "na"
        for (j = 0; j < data.length; j ++){
          ratio = parseInt(data[j]["maternal_mortality_ratio"])
          country = data[j]["GeographicArea"]
          if ((ratio > maxiRatio) & (top_countries.includes(country) == false)) {maxiRatio = ratio; topiCountry = country;}
        }
        top_ratios.push(maxiRatio)
        top_countries.push(topiCountry)
      }
      return({"topratios": top_ratios, "topcountries": top_countries})



    }

    function getTop10Data(data){
      let top10data = getTop10(data)
      let countries = top10data["topcountries"]
      top10data = data.filter((d) => {return countries.includes(d['GeographicArea'])})
      return(top10data)

    }


    let maxRatio = getTop10(data)["topratios"][0]
    var countries = getTop10(data)["topcountries"]
    var top10data = getTop10Data(data);


    const ratioScale = d3.scaleLinear()
                          .domain([0, maxRatio])
                          .range([chartHeight, 0]);



    const countryScale = d3.scaleBand().domain(countries)
                                      .range([0, chartWidth])
                                      .padding(0.05);

    let leftAxis = d3.axisLeft(ratioScale);
                          //.tickFormat(d3.format('.0%'));
    let leftGridlines = d3.axisLeft(ratioScale)
                          .tickSize(-chartWidth-10)
                          .tickFormat("");



    annotations.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(leftAxis)
    annotations.append("g")
               .attr("class", "y gridlines")
               .attr("transform",`translate(${margin.left-10},${margin.top})`)
               .call(leftGridlines);
    chartArea.append("text")
              .attr("class", "barlabels")
              .text("")


    let bottomAxis = d3.axisBottom()
    let bottomAxisG = annotations.append("g")
                                  .attr("class", "x axis")
                                  .attr("transform", `translate(${margin.left},${chartHeight+margin.top+10})`)



    const allIncomes = ["Low income", "Lower middle income", "Upper middle income", "High income", "All Countries"]
    allIncomes.forEach(d => {
      d3.select("div#button-bar")
        .append("button")
        .text(d)
        .on("click", function(){
          //Update
          updateBars(d);
          updateMap(d);
        })
    })
    function updateBars(incomeKey) {
      if (incomeKey == "All Countries"){
        var updatedData = data
      }
      else {
        var updatedData = data.filter((d) => {return d['IncomeGroup'] === incomeKey})
      }
      chartArea.selectAll('text.barlabels')
              .text("")

      top10Data = getTop10Data(updatedData)


      var countries = getTop10(updatedData)["topcountries"]
      const countryScale = d3.scaleBand().domain(countries)
                                        .range([0, chartWidth])
                                        .padding(0.05);


      bottomAxis.scale(countryScale)
      bottomAxisG.call(bottomAxis);

      chartArea.selectAll('rect.bar').data( top10Data )
              .join('rect').attr('class','bar')
              .attr("fill", '#6592bf')
              .attr("x", d => countryScale(d.GeographicArea))
              .attr("y", d => ratioScale(d.maternal_mortality_ratio))
              .attr("height", d => ratioScale(0) - ratioScale(d.maternal_mortality_ratio))
              .attr("width", countryScale.bandwidth())
              .attr("country", d => d["GeographicArea"]);

      top10Data.forEach((d, i) => {
        chartArea.append("text")
                  .attr("class", "barlabels")
                  .attr("text-anchor", "start")
                  .attr("font-size", "15px")
                  .attr("x", countryScale(d.GeographicArea) + countryScale.bandwidth()/4)
                  .attr("y", ratioScale( d['maternal_mortality_ratio'] ) - 10)
                  .text(d.maternal_mortality_ratio)
      })


  };

  updateBars("All Countries");

    //make the map

      const svgc = d3.select("#choropleth");
      const widthm = svgc.attr("width");
      const heightm = svgc.attr("height");
      const marginm = { top: 20, right: 320, bottom: 20, left:20};
      const mapWidth = widthm - marginm.left - marginm.right;
      const mapHeight = heightm - marginm.top - marginm.bottom;
      const map = svgc.append("g")
                      .attr("transform","translate("+marginm.left+","+marginm.top+")");
      countries = topojson.feature(countryData, countryData.objects.countries);
      countryMesh = topojson.mesh(countryData, countryData.objects.countries);






      var projection =  d3.geoPatterson()
                          .fitSize([mapWidth, mapHeight],countries);

      var path = d3.geoPath().projection(projection);


      const colorScale = d3.scaleQuantile()
                              .domain(Object.values(mortvals))
                              .range(['#dfdfc1', '#8bbdcc', '#6592bf', '#3f69af','#00429d' ]);

      drawLegend(d3.select("#colorLegend"), colorScale);

      function mapColors(d){
        if (mortvals[d.properties.name] == undefined){
          return('#d0d5d6')
        }
        else{ return colorScale(mortvals[d.properties.name])}
      }

      map.selectAll("path.countries").data(countries.features)
                                      .join("path")
                                      .attr("class", "country")
                                      .attr("note", d=>d.id)
                                      .attr("d", path)
                                      .on("click", clicked)
                                      .style("fill", d=>mapColors(d))
      map.append("path").datum(countryMesh)
                        .attr("class", "outlineCount")
                        .attr("d", path);


      const mouseover = svgc.append("g").attr("class","mouseover")
                                       .attr("transform",`translate(${mapWidth},${175})`);

      function stringLen(str) {
          const dummytext = mouseover.append("text").attr("class","legendtext").attr("visibility","hidden");
          dummytext.text(str)
          let len = dummytext.node().getComputedTextLength()
          dummytext.remove()
          return len;
        }

        const frame = mouseover.append("rect").attr("class","frame")
                                 .attr("x", 0).attr("y", 0)
                                 .attr("rx", 5).attr("ry", 5)  // rx and ry round corners
                                 .attr("height", 170);  // set width later
        const textbox = mouseover.append("g").attr("transform","translate(10,10)");
        const format = d3.format(',d');


        function clicked() {
          updateMap("All Countries")

          d3.select(this)
            .classed("clicked", true)

          textbox.html('');
          country = d3.select(this)



          let id = country.datum().id;
          let countryname = idToCountry[ id ]
          let countryInfo = data.filter( (d) => {return d['GeographicArea'] == countryname;}  )


          if(countryInfo.length != 0){
              let countryName = `Country: ${countryname}`;
              let year = `Year: ${countryInfo[0]['TimePeriod']}`;
              let mmr = `Maternal Mortality Ratio: ${countryInfo[0]['maternal_mortality_ratio']}`;
              let imr = `Infannt Mortality Rate: ${format(countryInfo[0]['infant_mortality_rate'])}`;
              let postnatalCare = `% Mothers Postnatal Care: ${d3.format(".0%")(countryInfo[0]['postnatal_care_mothers']/100)}`;
              let ecb = `Early Childbearing: ${countryInfo[0]['early_childbearing']}`;
              let pss = `Proportion Sanitation Services: ${d3.format(".0%")(countryInfo[0]['proportion_sanitation_services']/100)}`;
              let sba = `Skilled Birth Attendant: ${d3.format(".0%")(countryInfo[0]['skilled_birth_attendant']/100)}`;

              let maxWidth = Math.max( stringLen(countryName), stringLen(year), stringLen(mmr), stringLen(imr), stringLen(postnatalCare), stringLen(ecb), stringLen(pss), stringLen(sba) )
              frame.attr("width", maxWidth+20);
              textbox.append("text").text(countryName)
                      .attr("x", 0).attr("y", 10);
              textbox.append("text").text(year)
                    .attr("x", 0).attr("y", 30);
              textbox.append("text").text(mmr)
                    .attr("x", 0).attr("y", 50);
              textbox.append("text").text(imr)
                    .attr("x", 0).attr("y", 70);
              textbox.append("text").text(postnatalCare)
                    .attr("x", 0).attr("y", 90);
              textbox.append("text").text(ecb)
                    .attr("x", 0).attr("y", 110);
              textbox.append("text").text(pss)
                    .attr("x", 0).attr("y", 130);
              textbox.append("text").text(sba)
                    .attr("x", 0).attr("y", 150);

              f = mouseover.select("rect")
              f.style("stroke", "black")

              tooltip.style("visibility","hidden");
              textbox.raise()


          }
          if(countryInfo.length == 0){
            textbox.style("visibility","visible")
            f = mouseover.select("rect")
            f.style("stroke", "white")
          }
        }



        //Tool tip:
        let tooltipWidth = 170;
        let tooltipHeight = 40;
        let tooltip = map.append("g")
                 .attr("class","tooltip")
                 .attr("visibility","hidden");
        tooltip.append("rect")
                .attr("fill", "black")
                .attr("opacity", 0.7)
                .attr("x", -tooltipWidth / 2.0)
                .attr("y", 0)
                .attr("width",tooltipWidth)
                .attr("height",tooltipHeight)
        let txt = tooltip.append("text")
                        .attr("fill", "white")
                        .attr("text-anchor","middle")
                        .attr("alignment-baseline","hanging")
                        .attr("x", 0)
                        .attr("y", 2);
        let txt2 = tooltip.append("text")
                          .attr("fill", "white")
                          .attr("text-anchor","middle")
                          .attr("alignment-baseline","hanging")
                          .attr("x", 0)
                          .attr("y", 22);

      let momesh =  map.append("path")
                       .attr("class","mouseover outline")
                       .attr("d", "");


      d3.selectAll(".country").on("mouseenter", mouseEnter);
      d3.selectAll(".country").on("mouseout",  mouseLeavesPlot);

      let idToCountry = {}
      for (i = 0; i < countries.features.length; i++) {
        row = countries.features[i]
        id = row.id
        name = row.properties.name
        idToCountry[id] = name


      }



        function mouseEnter() {

          let country = d3.select(this);
          let id = country.datum().id;
          let countryname = idToCountry[ id ]
          let countryInfo = data.filter( (d) => {return d['GeographicArea'] == countryname;}  )
          if(countryInfo.length != 0){


            tooltip.style("visibility","visible")
            country.attr("stroke","black")
                  .attr("stroke-width", 3);


            txt.text(idToCountry[ id ]);

            txt2.text(countryInfo[0]["maternal_mortality_ratio"]);

            let centroid = path.centroid( country.datum() );
            let bounds = path.bounds( country.datum() );
            let xPos = (bounds[0][0]+bounds[1][0])/2.0;
            let yPos = bounds[1][1];
            tooltip.attr("transform",`translate(${xPos},${yPos})`);}

            country.raise()

            tooltip.raise()



        }

        function mouseLeavesPlot() {

         tooltip.style("visibility","hidden");

         let country = d3.select(this);
         country.attr("stroke","white")
              .attr("stroke-width", 0.5);

        textbox.raise()



          }



        function updateMap(incomeKey) {
          textbox.html('');
          f = mouseover.select("rect")
          f.style("stroke", "white")

          var liveCountries
          if (incomeKey == "All Countries"){
            var updatedData = data
            mortvals_up = mortvals
            liveCountries = allCountry
          }
          else {
            var updatedData = data.filter((d) => {return d['IncomeGroup'] === incomeKey})
            if(incomeKey == "Low income") {
              mortvals_up = low
              liveCountries = lowCountry}
            if(incomeKey == "Lower middle income"){
              mortvals_up = lowmid
              liveCountries = lowmidCountry}
            if(incomeKey == "Upper middle income"){
              mortvals_up = upmid
              liveCountries = upmidCountry}
            if(incomeKey == "High income"){
              mortvals_up = high
              liveCountries = highCountry}

          }




          const colorScalenew = d3.scaleQuantile()
                              .domain(Object.values(mortvals_up))
                              .range(['#dfdfc1', '#8bbdcc', '#6592bf', '#3f69af','#00429d' ]);


        cLeg = d3.select("svg#colorLegend")
        cLeg.selectAll("rect").remove();
        cLeg.selectAll("g").remove()
        drawLegend(d3.select("#colorLegend"), colorScalenew);

          function color(d){
            if(liveCountries.includes(d.properties.name)){
              return colorScalenew(mortvals_up[d.properties.name])}
            return("#d0d5d6")
          }

          map.selectAll("path.countries").data(countries.features)
                                              .join("path")
                                              .attr("class", "country")
                                              .attr("note", d=>d.id)
                                              .attr("d", path)
                                              .on("click", clicked)
                                              .style("fill", d=> color(d))
        map.append("path").datum(countryMesh)
                          .attr("class", "outlineCount")
                          .attr("d", path);

        d3.selectAll(".country").on("mouseenter", mouseEnter);
        d3.selectAll(".country").on("mouseout",  mouseLeavesPlot);

      };



      updateBars("All Countries");





        // Function needs a d3 selected SVG canvas where it will draw the legend and a source color scale
        function drawLegend(legend, legendColorScale) {

          // Bonus code here to draw an adaptive gradient legend so we can see different color scales for choropleth maps
          //  Credit Prof. Rz if you are basing a legend on this structure, and note SERIOUS PERFORMANCE CONSIDERATIONS

          //const legend = d3.select("#colorLegend");
          const legendWidth = legend.attr("width");
          const legendHeight = legend.attr("height");
          const legendMinMax = d3.extent(legendColorScale.domain()); // way to recover the minMax from most kinds of scales
          const barHeight = 60;
          const stepSize = 4; // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
          // Extend the minmax by 1 in either direction to expose more features
          const pixelScale = d3.scaleLinear().domain([0,legendWidth-40]).range([legendMinMax[0]-1,legendMinMax[1]+1]); // In this case the "data" are pixels, and we get numbers to use in colorScale
          const barScale = d3.scaleLinear().domain([legendMinMax[0]-1,legendMinMax[1]+1]).range([0,legendWidth-40]);
          const barAxis = d3.axisBottom(barScale);
          // Check if we're using a quantile scale - if so, we can do better
          if (legendColorScale.hasOwnProperty('quantiles')) {
            // Use the quantile breakpoints plus the min and max of the scale as tick values
            barAxis.tickValues(legendColorScale.quantiles().concat( legendMinMax ));
          }
          legend.append("g")
            .attr("class", "colorbar axis")
            .attr("transform","translate("+(20)+","+(barHeight+5)+")")
            .call(barAxis);
          // Draw rects of color down the bar
          let bar = legend.append("g").attr("transform","translate("+(20)+","+(0)+")")
          for (let i=0; i<legendWidth-40; i=i+stepSize) {
            bar.append("rect")
              .attr("x", i)
              .attr("y", 0)
              .attr("width", stepSize)
              .attr("height",barHeight)
              .style("fill", legendColorScale( pixelScale(i) )); // pixels => countData => color
          }
          // Put lines in to mark actual min and max of our data
          bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[0])).attr("x2", barScale(legendMinMax[0])).attr("y1", 0).attr("y1", barHeight+4);
          bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[1])).attr("x2", barScale(legendMinMax[1])).attr("y1", 0).attr("y1", barHeight+4);

        }











  };
  requestData();

  </script>








</body>
</html>
